#include "pch.h"
#include "audio/audiomanagerfmod.h"

namespace engine
{
	std::string getStringFromFMODResult(FMOD_RESULT result)
	{
		#define FMOD_ERROR_STR(RESULT) \
			case RESULT: return #RESULT

		switch (result)
		{
			FMOD_ERROR_STR(FMOD_OK);
			FMOD_ERROR_STR(FMOD_ERR_BADCOMMAND);
			FMOD_ERROR_STR(FMOD_ERR_CHANNEL_ALLOC);
			FMOD_ERROR_STR(FMOD_ERR_CHANNEL_STOLEN);
			FMOD_ERROR_STR(FMOD_ERR_DMA);
			FMOD_ERROR_STR(FMOD_ERR_DSP_CONNECTION);
			FMOD_ERROR_STR(FMOD_ERR_DSP_DONTPROCESS);
			FMOD_ERROR_STR(FMOD_ERR_DSP_FORMAT);
			FMOD_ERROR_STR(FMOD_ERR_DSP_INUSE);
			FMOD_ERROR_STR(FMOD_ERR_DSP_NOTFOUND);
			FMOD_ERROR_STR(FMOD_ERR_DSP_RESERVED);
			FMOD_ERROR_STR(FMOD_ERR_DSP_SILENCE);
			FMOD_ERROR_STR(FMOD_ERR_DSP_TYPE);
			FMOD_ERROR_STR(FMOD_ERR_FILE_BAD);
			FMOD_ERROR_STR(FMOD_ERR_FILE_COULDNOTSEEK);
			FMOD_ERROR_STR(FMOD_ERR_FILE_DISKEJECTED);
			FMOD_ERROR_STR(FMOD_ERR_FILE_EOF);
			FMOD_ERROR_STR(FMOD_ERR_FILE_ENDOFDATA);
			FMOD_ERROR_STR(FMOD_ERR_FILE_NOTFOUND);
			FMOD_ERROR_STR(FMOD_ERR_FORMAT);
			FMOD_ERROR_STR(FMOD_ERR_HEADER_MISMATCH);
			FMOD_ERROR_STR(FMOD_ERR_HTTP);
			FMOD_ERROR_STR(FMOD_ERR_HTTP_ACCESS);
			FMOD_ERROR_STR(FMOD_ERR_HTTP_PROXY_AUTH);
			FMOD_ERROR_STR(FMOD_ERR_HTTP_SERVER_ERROR);
			FMOD_ERROR_STR(FMOD_ERR_HTTP_TIMEOUT);
			FMOD_ERROR_STR(FMOD_ERR_INITIALIZATION);
			FMOD_ERROR_STR(FMOD_ERR_INITIALIZED);
			FMOD_ERROR_STR(FMOD_ERR_INTERNAL);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_FLOAT);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_HANDLE);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_PARAM);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_POSITION);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_SPEAKER);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_SYNCPOINT);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_THREAD);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_VECTOR);
			FMOD_ERROR_STR(FMOD_ERR_MAXAUDIBLE);
			FMOD_ERROR_STR(FMOD_ERR_MEMORY);
			FMOD_ERROR_STR(FMOD_ERR_MEMORY_CANTPOINT);
			FMOD_ERROR_STR(FMOD_ERR_NEEDS3D);
			FMOD_ERROR_STR(FMOD_ERR_NEEDSHARDWARE);
			FMOD_ERROR_STR(FMOD_ERR_NET_CONNECT);
			FMOD_ERROR_STR(FMOD_ERR_NET_SOCKET_ERROR);
			FMOD_ERROR_STR(FMOD_ERR_NET_URL);
			FMOD_ERROR_STR(FMOD_ERR_NET_WOULD_BLOCK);
			FMOD_ERROR_STR(FMOD_ERR_NOTREADY);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_ALLOCATED);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_CREATEBUFFER);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_DRIVERCALL);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_FORMAT);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_INIT);
			FMOD_ERROR_STR(FMOD_ERR_OUTPUT_NODRIVERS);
			FMOD_ERROR_STR(FMOD_ERR_PLUGIN);
			FMOD_ERROR_STR(FMOD_ERR_PLUGIN_MISSING);
			FMOD_ERROR_STR(FMOD_ERR_PLUGIN_RESOURCE);
			FMOD_ERROR_STR(FMOD_ERR_PLUGIN_VERSION);
			FMOD_ERROR_STR(FMOD_ERR_RECORD);
			FMOD_ERROR_STR(FMOD_ERR_REVERB_CHANNELGROUP);
			FMOD_ERROR_STR(FMOD_ERR_REVERB_INSTANCE);
			FMOD_ERROR_STR(FMOD_ERR_SUBSOUNDS);
			FMOD_ERROR_STR(FMOD_ERR_SUBSOUND_ALLOCATED);
			FMOD_ERROR_STR(FMOD_ERR_SUBSOUND_CANTMOVE);
			FMOD_ERROR_STR(FMOD_ERR_TAGNOTFOUND);
			FMOD_ERROR_STR(FMOD_ERR_TOOMANYCHANNELS);
			FMOD_ERROR_STR(FMOD_ERR_TRUNCATED);
			FMOD_ERROR_STR(FMOD_ERR_UNIMPLEMENTED);
			FMOD_ERROR_STR(FMOD_ERR_UNINITIALIZED);
			FMOD_ERROR_STR(FMOD_ERR_UNSUPPORTED);
			FMOD_ERROR_STR(FMOD_ERR_VERSION);
			FMOD_ERROR_STR(FMOD_ERR_EVENT_ALREADY_LOADED);
			FMOD_ERROR_STR(FMOD_ERR_EVENT_LIVEUPDATE_BUSY);
			FMOD_ERROR_STR(FMOD_ERR_EVENT_LIVEUPDATE_MISMATCH);
			FMOD_ERROR_STR(FMOD_ERR_EVENT_LIVEUPDATE_TIMEOUT);
			FMOD_ERROR_STR(FMOD_ERR_EVENT_NOTFOUND);
			FMOD_ERROR_STR(FMOD_ERR_STUDIO_UNINITIALIZED);
			FMOD_ERROR_STR(FMOD_ERR_STUDIO_NOT_LOADED);
			FMOD_ERROR_STR(FMOD_ERR_INVALID_STRING);
			FMOD_ERROR_STR(FMOD_ERR_ALREADY_LOCKED);
			FMOD_ERROR_STR(FMOD_ERR_NOT_LOCKED);
			FMOD_ERROR_STR(FMOD_ERR_RECORD_DISCONNECTED);
			FMOD_ERROR_STR(FMOD_ERR_TOOMANYSAMPLES);
			FMOD_ERROR_STR(FMOD_RESULT_FORCEINT);
		default:
			break;
		}

		return "unknown fmod result";
	}

	AudioManagerFmod AudioManagerFmod::ms_instance;

	AudioManagerFmod::AudioManagerFmod()
	{
		m_fmodSystem = nullptr;
	}

	AudioManagerFmod::~AudioManagerFmod()
	{
		m_fmodSystem = nullptr;
	}

	void AudioManagerFmod::init()
	{
		FMOD_RESULT result = FMOD::System_Create(&m_fmodSystem);
		if (result != FMOD_OK)
		{
			spdlog::error("[audio]: failed to create fmod !");
			spdlog::error("[audio]: FMOD ERROR: {}", getStringFromFMODResult(result));

			std::terminate();
		}

		unsigned int version = 0;
		m_fmodSystem->getVersion(&version);

		if (version < FMOD_VERSION)
		{
			spdlog::error("[audio]: FMOD lib version {} doesn't match header version {}", version, FMOD_VERSION);
			std::terminate();
		}

		result = m_fmodSystem->init(32, FMOD_INIT_NORMAL, nullptr);
		if (result != FMOD_OK)
		{
			spdlog::error("[audio]: failed to initialize fmod !");
			spdlog::error("[audio]: FMOD ERROR: {}", getStringFromFMODResult(result));

			std::terminate();
		}

		spdlog::info("[audio]: fmod initialized");

	}

	void AudioManagerFmod::shutdown()
	{
		FMOD_RESULT result = m_fmodSystem->close();
		if (result != FMOD_OK)
		{
			spdlog::error("[audio]: failed to close fmod !");
			spdlog::error("[audio]: FMOD ERROR: {}", getStringFromFMODResult(result));

			std::terminate();
		}

		result = m_fmodSystem->release();
		if (result != FMOD_OK)
		{
			spdlog::error("[audio]: failed to release fmod !");
			spdlog::error("[audio]: FMOD ERROR: {}", getStringFromFMODResult(result));

			std::terminate();
		}

		m_fmodSystem = nullptr;
	}
}